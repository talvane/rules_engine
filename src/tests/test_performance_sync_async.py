#!/usr/bin/env python3
"""
Teste de Performance: JSON Logic Sync vs Async
Compara a performance do processamento s√≠ncrono vs ass√≠ncrono
"""

import sys
import os
import time
import asyncio
import random
from typing import List, Dict, Callable
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

# Adiciona o path para importar o m√≥dulo
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", ".."))

from src.lib.json_logic import jsonLogic, jsonLogicAsync, jsonLogicAuto


class PerformanceTest:
    """Classe para testes de performance sync vs async"""

    def __init__(self):
        self.results = {}

    # ========== FUN√á√ïES DE TESTE ==========

    def operacao_simples(self, x, y):
        """Opera√ß√£o matem√°tica simples"""
        return x * y + (x - y)

    def operacao_media(self, lista_numeros):
        """Opera√ß√£o de complexidade m√©dia - c√°lculos com lista"""
        if not lista_numeros:
            return 0
        soma = sum(lista_numeros)
        media = soma / len(lista_numeros)
        variancia = sum((x - media) ** 2 for x in lista_numeros) / len(lista_numeros)
        return round(media + variancia, 2)

    def operacao_complexa(self, texto, pattern, multiplicador):
        """Opera√ß√£o mais complexa - processamento de string"""
        # Simula processamento de string mais pesado
        result = 0
        for i, char in enumerate(texto.lower()):
            if pattern.lower() in char:
                result += ord(char) * multiplicador * (i + 1)
        
        # Adiciona algum processamento adicional
        palavras = texto.split()
        for palavra in palavras:
            result += len(palavra) * multiplicador
        
        return result % 10000

    async def operacao_simples_async(self, x, y):
        """Vers√£o ass√≠ncrona da opera√ß√£o simples"""
        # Simula uma pequena lat√™ncia I/O
        await asyncio.sleep(0.001)  # 1ms
        return x * y + (x - y)

    async def operacao_media_async(self, lista_numeros):
        """Vers√£o ass√≠ncrona da opera√ß√£o m√©dia"""
        # Simula lat√™ncia I/O m√©dia
        await asyncio.sleep(0.005)  # 5ms
        if not lista_numeros:
            return 0
        soma = sum(lista_numeros)
        media = soma / len(lista_numeros)
        variancia = sum((x - media) ** 2 for x in lista_numeros) / len(lista_numeros)
        return round(media + variancia, 2)

    async def operacao_complexa_async(self, texto, pattern, multiplicador):
        """Vers√£o ass√≠ncrona da opera√ß√£o complexa"""
        # Simula lat√™ncia I/O alta
        await asyncio.sleep(0.010)  # 10ms
        result = 0
        for i, char in enumerate(texto.lower()):
            if pattern.lower() in char:
                result += ord(char) * multiplicador * (i + 1)
        
        palavras = texto.split()
        for palavra in palavras:
            result += len(palavra) * multiplicador
        
        return result % 10000

    def get_sync_functions(self):
        """Retorna fun√ß√µes s√≠ncronas"""
        return {
            "op_simples": self.operacao_simples,
            "op_media": self.operacao_media,
            "op_complexa": self.operacao_complexa,
        }

    def get_async_functions(self):
        """Retorna fun√ß√µes ass√≠ncronas"""
        return {
            "op_simples": self.operacao_simples_async,
            "op_media": self.operacao_media_async,
            "op_complexa": self.operacao_complexa_async,
        }

    def get_mixed_functions(self):
        """Retorna mix de fun√ß√µes s√≠ncronas e ass√≠ncronas"""
        return {
            "op_simples": self.operacao_simples,  # Sync
            "op_media": self.operacao_media_async,  # Async
            "op_complexa": self.operacao_complexa,  # Sync
        }

    def gerar_dados_teste(self):
        """Gera dados de teste variados"""
        return [
            {
                "x": random.randint(1, 100),
                "y": random.randint(1, 100),
                "lista": [random.randint(1, 50) for _ in range(10)],
                "texto": f"Texto de teste {random.randint(1, 1000)} com padr√£o abc",
                "pattern": random.choice(["a", "e", "t", "x"]),
                "mult": random.randint(1, 10)
            }
            for _ in range(100)
        ]

    def gerar_regras_teste(self):
        """Gera regras JSON Logic para teste"""
        return [
            # Regra simples
            {
                "apply": [
                    "op_simples",
                    {"var": "x"},
                    {"var": "y"}
                ]
            },
            # Regra m√©dia
            {
                "apply": [
                    "op_media",
                    {"var": "lista"}
                ]
            },
            # Regra complexa
            {
                "apply": [
                    "op_complexa",
                    {"var": "texto"},
                    {"var": "pattern"},
                    {"var": "mult"}
                ]
            },
            # Regra combinada
            {
                "+": [
                    {
                        "apply": [
                            "op_simples",
                            {"var": "x"},
                            {"var": "y"}
                        ]
                    },
                    {
                        "apply": [
                            "op_media",
                            {"var": "lista"}
                        ]
                    }
                ]
            },
            # Regra condicional
            {
                "if": [
                    {">": [{"var": "x"}, 50]},
                    {
                        "apply": [
                            "op_complexa",
                            {"var": "texto"},
                            {"var": "pattern"},
                            {"var": "mult"}
                        ]
                    },
                    {
                        "apply": [
                            "op_simples",
                            {"var": "x"},
                            {"var": "y"}
                        ]
                    }
                ]
            }
        ]

    def executar_teste_sync(self, num_execucoes=1000):
        """Executa teste s√≠ncrono"""
        print(f"üîÑ Executando teste S√çNCRONO ({num_execucoes} execu√ß√µes)")
        print("-" * 50)

        functions = self.get_sync_functions()
        dados_teste = self.gerar_dados_teste()
        regras_teste = self.gerar_regras_teste()

        sucessos = 0
        erros = 0
        tempos = []

        inicio_total = time.time()

        for i in range(num_execucoes):
            regra = random.choice(regras_teste)
            dados = random.choice(dados_teste)

            try:
                inicio = time.time()
                resultado = jsonLogic(regra, dados, functions)
                fim = time.time()

                tempo_execucao = fim - inicio
                tempos.append(tempo_execucao)
                sucessos += 1

            except Exception as e:
                erros += 1
                if erros <= 3:
                    print(f"   ‚ùå Erro sync {i+1}: {e}")

        fim_total = time.time()
        tempo_total = fim_total - inicio_total

        # Calcula estat√≠sticas
        tempo_medio = sum(tempos) / len(tempos) if tempos else 0
        tempo_min = min(tempos) if tempos else 0
        tempo_max = max(tempos) if tempos else 0

        resultado = {
            "tipo": "sync",
            "execucoes": num_execucoes,
            "sucessos": sucessos,
            "erros": erros,
            "tempo_total": tempo_total,
            "tempo_medio": tempo_medio,
            "tempo_min": tempo_min,
            "tempo_max": tempo_max,
            "throughput": sucessos / tempo_total if tempo_total > 0 else 0
        }

        self.results["sync"] = resultado
        self.imprimir_resultado_sync(resultado)
        return resultado

    async def executar_teste_async(self, num_execucoes=1000):
        """Executa teste ass√≠ncrono"""
        print(f"\nüîÑ Executando teste ASS√çNCRONO ({num_execucoes} execu√ß√µes)")
        print("-" * 50)

        functions = self.get_async_functions()
        dados_teste = self.gerar_dados_teste()
        regras_teste = self.gerar_regras_teste()

        sucessos = 0
        erros = 0
        tempos = []

        inicio_total = time.time()

        for i in range(num_execucoes):
            regra = random.choice(regras_teste)
            dados = random.choice(dados_teste)

            try:
                inicio = time.time()
                resultado = await jsonLogicAsync(regra, dados, functions)
                fim = time.time()

                tempo_execucao = fim - inicio
                tempos.append(tempo_execucao)
                sucessos += 1

            except Exception as e:
                erros += 1
                if erros <= 3:
                    print(f"   ‚ùå Erro async {i+1}: {e}")

        fim_total = time.time()
        tempo_total = fim_total - inicio_total

        # Calcula estat√≠sticas
        tempo_medio = sum(tempos) / len(tempos) if tempos else 0
        tempo_min = min(tempos) if tempos else 0
        tempo_max = max(tempos) if tempos else 0

        resultado = {
            "tipo": "async",
            "execucoes": num_execucoes,
            "sucessos": sucessos,
            "erros": erros,
            "tempo_total": tempo_total,
            "tempo_medio": tempo_medio,
            "tempo_min": tempo_min,
            "tempo_max": tempo_max,
            "throughput": sucessos / tempo_total if tempo_total > 0 else 0
        }

        self.results["async"] = resultado
        self.imprimir_resultado_async(resultado)
        return resultado

    async def executar_teste_async_concorrente(self, num_execucoes=1000, concorrencia=10):
        """Executa teste ass√≠ncrono com concorr√™ncia"""
        print(f"\nüöÄ Executando teste ASS√çNCRONO CONCORRENTE ({num_execucoes} execu√ß√µes, {concorrencia} concorrentes)")
        print("-" * 60)

        functions = self.get_async_functions()
        dados_teste = self.gerar_dados_teste()
        regras_teste = self.gerar_regras_teste()

        sucessos = 0
        erros = 0
        tempos = []

        async def executar_lote(lote_size):
            nonlocal sucessos, erros, tempos
            tasks = []
            
            for _ in range(lote_size):
                regra = random.choice(regras_teste)
                dados = random.choice(dados_teste)
                
                async def executar_regra():
                    try:
                        inicio = time.time()
                        resultado = await jsonLogicAsync(regra, dados, functions)
                        fim = time.time()
                        return fim - inicio, True, None
                    except Exception as e:
                        return 0, False, str(e)
                
                tasks.append(executar_regra())
            
            results = await asyncio.gather(*tasks)
            
            for tempo, sucesso, erro in results:
                if sucesso:
                    sucessos += 1
                    tempos.append(tempo)
                else:
                    erros += 1

        inicio_total = time.time()

        # Executa em lotes concorrentes
        lotes = [concorrencia] * (num_execucoes // concorrencia)
        if num_execucoes % concorrencia:
            lotes.append(num_execucoes % concorrencia)

        for lote_size in lotes:
            await executar_lote(lote_size)

        fim_total = time.time()
        tempo_total = fim_total - inicio_total

        # Calcula estat√≠sticas
        tempo_medio = sum(tempos) / len(tempos) if tempos else 0
        tempo_min = min(tempos) if tempos else 0
        tempo_max = max(tempos) if tempos else 0

        resultado = {
            "tipo": "async_concurrent",
            "execucoes": num_execucoes,
            "concorrencia": concorrencia,
            "sucessos": sucessos,
            "erros": erros,
            "tempo_total": tempo_total,
            "tempo_medio": tempo_medio,
            "tempo_min": tempo_min,
            "tempo_max": tempo_max,
            "throughput": sucessos / tempo_total if tempo_total > 0 else 0
        }

        self.results["async_concurrent"] = resultado
        self.imprimir_resultado_async_concurrent(resultado)
        return resultado

    async def executar_teste_mixed(self, num_execucoes=1000):
        """Executa teste com fun√ß√µes mistas usando jsonLogicAuto"""
        print(f"\nüéØ Executando teste MISTO (jsonLogicAuto) ({num_execucoes} execu√ß√µes)")
        print("-" * 60)

        functions = self.get_mixed_functions()
        dados_teste = self.gerar_dados_teste()
        regras_teste = self.gerar_regras_teste()

        sucessos = 0
        erros = 0
        tempos = []

        inicio_total = time.time()

        for i in range(num_execucoes):
            regra = random.choice(regras_teste)
            dados = random.choice(dados_teste)

            try:
                inicio = time.time()
                resultado = jsonLogicAuto(regra, dados, functions)
                
                # Se retornou uma corrotina, aguarda
                if asyncio.iscoroutine(resultado):
                    resultado = await resultado
                
                fim = time.time()

                tempo_execucao = fim - inicio
                tempos.append(tempo_execucao)
                sucessos += 1

            except Exception as e:
                erros += 1
                if erros <= 3:
                    print(f"   ‚ùå Erro mixed {i+1}: {e}")

        fim_total = time.time()
        tempo_total = fim_total - inicio_total

        # Calcula estat√≠sticas
        tempo_medio = sum(tempos) / len(tempos) if tempos else 0
        tempo_min = min(tempos) if tempos else 0
        tempo_max = max(tempos) if tempos else 0

        resultado = {
            "tipo": "mixed",
            "execucoes": num_execucoes,
            "sucessos": sucessos,
            "erros": erros,
            "tempo_total": tempo_total,
            "tempo_medio": tempo_medio,
            "tempo_min": tempo_min,
            "tempo_max": tempo_max,
            "throughput": sucessos / tempo_total if tempo_total > 0 else 0
        }

        self.results["mixed"] = resultado
        self.imprimir_resultado_mixed(resultado)
        return resultado

    def imprimir_resultado_sync(self, resultado):
        """Imprime resultado do teste s√≠ncrono"""
        print("üìä Resultados SYNC:")
        print(f"   ‚úÖ Sucessos: {resultado['sucessos']}")
        print(f"   ‚ùå Erros: {resultado['erros']}")
        print(f"   ‚è±Ô∏è  Tempo total: {resultado['tempo_total']:.3f}s")
        print(f"   üìà Tempo m√©dio: {resultado['tempo_medio']*1000:.3f}ms")
        print(f"   üöÄ Throughput: {resultado['throughput']:.0f} ops/s")

    def imprimir_resultado_async(self, resultado):
        """Imprime resultado do teste ass√≠ncrono"""
        print("üìä Resultados ASYNC:")
        print(f"   ‚úÖ Sucessos: {resultado['sucessos']}")
        print(f"   ‚ùå Erros: {resultado['erros']}")
        print(f"   ‚è±Ô∏è  Tempo total: {resultado['tempo_total']:.3f}s")
        print(f"   üìà Tempo m√©dio: {resultado['tempo_medio']*1000:.3f}ms")
        print(f"   üöÄ Throughput: {resultado['throughput']:.0f} ops/s")

    def imprimir_resultado_async_concurrent(self, resultado):
        """Imprime resultado do teste ass√≠ncrono concorrente"""
        print("üìä Resultados ASYNC CONCURRENT:")
        print(f"   ‚úÖ Sucessos: {resultado['sucessos']}")
        print(f"   ‚ùå Erros: {resultado['erros']}")
        print(f"   üîó Concorr√™ncia: {resultado['concorrencia']}")
        print(f"   ‚è±Ô∏è  Tempo total: {resultado['tempo_total']:.3f}s")
        print(f"   üìà Tempo m√©dio: {resultado['tempo_medio']*1000:.3f}ms")
        print(f"   üöÄ Throughput: {resultado['throughput']:.0f} ops/s")

    def imprimir_resultado_mixed(self, resultado):
        """Imprime resultado do teste misto"""
        print("üìä Resultados MIXED (jsonLogicAuto):")
        print(f"   ‚úÖ Sucessos: {resultado['sucessos']}")
        print(f"   ‚ùå Erros: {resultado['erros']}")
        print(f"   ‚è±Ô∏è  Tempo total: {resultado['tempo_total']:.3f}s")
        print(f"   üìà Tempo m√©dio: {resultado['tempo_medio']*1000:.3f}ms")
        print(f"   üöÄ Throughput: {resultado['throughput']:.0f} ops/s")

    def comparar_resultados(self):
        """Compara os resultados dos testes"""
        print("\n" + "=" * 80)
        print("üìä COMPARA√á√ÉO DE PERFORMANCE: SYNC vs ASYNC")
        print("=" * 80)

        if "sync" not in self.results or "async" not in self.results:
            print("‚ùå Nem todos os testes foram executados")
            return

        sync = self.results["sync"]
        async_result = self.results["async"]

        print(f"{'M√©trica':<25} {'SYNC':<15} {'ASYNC':<15} {'Diferen√ßa':<15}")
        print("-" * 70)

        # Throughput
        sync_throughput = sync['throughput']
        async_throughput = async_result['throughput']
        diff_throughput = ((async_throughput - sync_throughput) / sync_throughput * 100) if sync_throughput > 0 else 0
        print(f"{'Throughput (ops/s)':<25} {sync_throughput:<15.0f} {async_throughput:<15.0f} {diff_throughput:+.1f}%")

        # Tempo m√©dio
        sync_time = sync['tempo_medio'] * 1000
        async_time = async_result['tempo_medio'] * 1000
        diff_time = ((async_time - sync_time) / sync_time * 100) if sync_time > 0 else 0
        print(f"{'Tempo m√©dio (ms)':<25} {sync_time:<15.3f} {async_time:<15.3f} {diff_time:+.1f}%")

        # Tempo total
        sync_total = sync['tempo_total']
        async_total = async_result['tempo_total']
        diff_total = ((async_total - sync_total) / sync_total * 100) if sync_total > 0 else 0
        print(f"{'Tempo total (s)':<25} {sync_total:<15.3f} {async_total:<15.3f} {diff_total:+.1f}%")

        # Taxa de sucesso
        sync_success = (sync['sucessos'] / sync['execucoes'] * 100)
        async_success = (async_result['sucessos'] / async_result['execucoes'] * 100)
        print(f"{'Taxa de sucesso (%)':<25} {sync_success:<15.1f} {async_success:<15.1f}")

        # Conclus√µes
        print("\nüìã CONCLUS√ïES:")
        if async_throughput > sync_throughput:
            print(f"‚úÖ ASYNC √© {(async_throughput/sync_throughput):.1f}x mais r√°pido em throughput")
        else:
            print(f"‚ö†Ô∏è  SYNC √© {(sync_throughput/async_throughput):.1f}x mais r√°pido em throughput")

        if "async_concurrent" in self.results:
            concurrent = self.results["async_concurrent"]
            concurrent_throughput = concurrent['throughput']
            print(f"üöÄ ASYNC CONCURRENT: {concurrent_throughput:.0f} ops/s ({(concurrent_throughput/sync_throughput):.1f}x sync)")

        # Recomenda√ß√µes
        print("\nüéØ RECOMENDA√á√ïES:")
        print("‚úÖ Use SYNC para: opera√ß√µes r√°pidas, CPU-intensivas, sem I/O")
        print("‚úÖ Use ASYNC para: opera√ß√µes com I/O, lat√™ncia de rede, APIs externas")
        print("‚úÖ Use ASYNC CONCURRENT para: m√∫ltiplas opera√ß√µes I/O paralelas")
        print("‚úÖ Use jsonLogicAuto para: detectar automaticamente o melhor modo")


async def main():
    """Executa todos os testes de performance"""
    print("üöÄ TESTE DE PERFORMANCE: JSON LOGIC SYNC vs ASYNC")
    print("=" * 80)
    print("Comparando performance entre processamento s√≠ncrono e ass√≠ncrono")
    print("=" * 80)

    teste = PerformanceTest()
    
    # Configura√ß√£o de testes
    num_execucoes = 1000
    concorrencia = 20

    # Executa testes
    teste.executar_teste_sync(num_execucoes)
    await teste.executar_teste_async(num_execucoes)
    await teste.executar_teste_async_concorrente(num_execucoes, concorrencia)
    await teste.executar_teste_mixed(num_execucoes)
    
    # Compara resultados
    teste.comparar_resultados()

    print("\nüéâ Testes de performance conclu√≠dos!")
    print("üí° Os resultados mostram as caracter√≠sticas de cada abordagem")
    print("üìà Use essas m√©tricas para escolher a melhor estrat√©gia para seu caso")


if __name__ == "__main__":
    asyncio.run(main())
